 ## chapter07. 캡슐화
 
 ### 7.1 레코드 캡슐화 하기
 - 게터는 데이터 구조를 깊이 탐색하게 만들되 원본 데이터 그대로 반환하지 말고 객체로 감싸서 반환하는게 효과적(깊은 복사)
 
### 7.2 컬렉션 캡슐화하기
- 가변 데이터의 데이터 가공을 '컬렉션 변경자 메서드'를 통해 발생하도록 캡슐화 한다.
ex - addCourse, removeCourse
- 컬렉션 자체를 통째로 바꾸는 세터는 제거한다.
만일 제거할 상황이 아니라면 인수로 받는 컬렉션을 복제해 저장한다.
```javascript
set courses(aList){
  this._courses = aList
}

=>after > delete or...

set courses(aList){
  this._courses = aList.slice()
}
```
### 7.3 기본형을 객체로 바꾸기
데이터가 단순 출력 이상의 기능이 필요해지는 순간 데이터를 표현하는 전용 클래스를 정의
기능이 더 추가될때 클래스에 추가하면 되기 때문에 유용한 도구가 된다.

### 7.4 임시 변수를 질의 함수로 바꾸기
함수 내 어떤 코드의 결과값을 뒤에서 다시 참조할 목적으로 임시 변수를 쓰기도 한다. 임시 변수를 사용하여 값을 계산하는 코드가 반복되는 것을 줄일 수 있고, 값의 의미를 설명할 수 유용하다. 이 임시변수를 아예 함수로 만들어 사용하는 것이 더 낫다. 추출함수와 원래 함수의 경계가 더 분명해지고 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복을 줄 일 수 있다.

### 7.5 클래스 추출하기
메서드와 데이터가 너무 많은 클래스는 이해하기 어려우므로 적절히 분리하는 것이 좋다. 역할을 기반으로 분리하고 연관된 의존 데이터들도 분리한다.

### 7.6 클래스 인라인하기
7.5클래스 추출하기를 통해 분리했으나 분리한 특정 클래스에 역할이 거의 없을 때에는 많이 사용하는 클래스로 흡수시킨다.

### 7.7 위임 숨기기
클라이언트가 데이터를 얻기위한 작동방식을 아는 것 => 의존성
캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여 의존성을 줄여준다.
```js
ex) manager = person.department.manager
-> manager = person.manager
```

클라이언트가 manager를 얻기 위해 person과 department클래스를 통해서 얻을 수 있음을 미리 알고있어야 하지만
위임을 미리 해두면 department클래스를 알지 못해도 데이터를 얻을 수 있다.



### 7.8 중개자 제거하기
7.7에서 소개된 위임방식이 과해질 경우
하나의 클래스가 위임만 하는 역할을 갖게 될 수 있다. (only 중개자)
그런 경우 과감히 위임역할을 당한 클래스를 제거하고 클라이언트에서 직접 위임 객체를 호출하는게 나을 수 있다.
```js
ex) manager = person.manager
-> manager = person.department.manager (직접 호출)
```

즉, 뭐든 적당히가 중요


### 7.9 알고리즘 교체하기
교체할 알고리즘을 하나의 함수에 모은다.
함수를 대체하고 테스트 한다.
원활하게 하기 위해서는 반드시 메서드를 가능한 잘게 나누는 것이 선행되어야 한다.

